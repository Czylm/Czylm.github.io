<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fractal Streets</title>
    <url>/2023/12/13/Fractal-Streets/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>将原来的城市复制一遍放在原城市的上方，将原城市顺时针90°放在原城市的左上方，将逆时针90°后的城市放在原城市的左边，然后用道路将四部分链接起来，反复进行相同操作。</p>
</blockquote>
<p><img src="/2023/12/13/Fractal-Streets/image.png" alt></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>这是著名的通过一定规律无限包含自身的“分形”图。为了方便计算，我们把标号从 $0$ 开始<br>解题关键就是，求编号为 $M$ 的房屋在 $N$ 级城市的位置，把问题转化为 calc(N,M),因此改题目转化为求 $calc(N,A)$ 与 $calc(N,B)$ 的距离。<br>在求解 $calc(N,M)$ 时，因为 $N - 1$ 级城市有 $2 ^ {2 <em> N - 2}$ 座房屋，所以我们先求解 $calc(N - 1,M mod 2 ^ {2 </em> N - 2})$,根据房屋编号 M 与 该级数的房屋总数确定编号上下左右位置。<br><img src="/2023/12/13/Fractal-Streets/转化.jpg" alt></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1314</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function">PII <span class="title">calc</span><span class="params">(LL n,LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	LL len = <span class="number">1ll</span> &lt;&lt; (n - <span class="number">1</span>),cnt = <span class="number">1ll</span> &lt;&lt; (<span class="number">2</span> * n - <span class="number">2</span>);<span class="comment">//每一级的半长和多少个 1 级的 </span></span><br><span class="line">	PII pos = <span class="built_in">calc</span>(n - <span class="number">1</span>,m % cnt);</span><br><span class="line">	LL x = pos.first, y = pos.second;</span><br><span class="line">	LL z = m / cnt;</span><br><span class="line">	<span class="keyword">if</span>(z == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(y,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(x,y + len);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(x + len,y + len);</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">2</span> * len - y - <span class="number">1</span>,len - x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --)</span><br><span class="line">	&#123;</span><br><span class="line">		LL N,A,B;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;</span><br><span class="line">		PII a = <span class="built_in">calc</span>(N,A - <span class="number">1</span>),b = <span class="built_in">calc</span>(N,B - <span class="number">1</span>);</span><br><span class="line">		LL x = a.first - b.first, y = a.second - b.second;</span><br><span class="line">		cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">0</span>) &lt;&lt; <span class="built_in">sqrt</span>(x * x + y * y) * <span class="number">10</span> &lt;&lt; endl; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>分形</tag>
      </tags>
  </entry>
  <entry>
    <title>Cinema</title>
    <url>/2023/12/18/Cinema/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2023/12/18/Cinema/image.png" alt></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>将 $m$ 部电影和 $n$ 个人最多涉及的 $2 <em> m + n$ 种语言放进一个数组，排序离散化，然后用这个 $[1,2 </em> m + n]$ 范围内大小的整数代替每一个语言，此时我们就可以用数组直接统计每一种语言的人的数量，进而循环找出符合题意的序号电影</p>
</blockquote>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n;  i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        d.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; m; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        d.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">        d.<span class="built_in">push_back</span>(c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>());</span><br><span class="line">    d.<span class="built_in">erase</span>(<span class="built_in">unique</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>()),d.<span class="built_in">end</span>());</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>(),a[i]) - d.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; m; i ++)&#123;</span><br><span class="line">        b[i] = <span class="built_in">lower_bound</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>(),b[i]) - d.<span class="built_in">begin</span>();</span><br><span class="line">        c[i] = <span class="built_in">lower_bound</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>(),c[i]) - d.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++)&#123;</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> max1 = <span class="number">-1</span>,max2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max1 &lt; cnt[b[i]])&#123;</span><br><span class="line">            max1 = cnt[b[i]];</span><br><span class="line">            max2 = cnt[c[i]];</span><br><span class="line">            x = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt[b[i]] == max1 &amp;&amp; cnt[c[i]] &gt; max2)&#123;</span><br><span class="line">            max2 = cnt[c[i]];</span><br><span class="line">            x = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>IP数据包分片重组</title>
    <url>/2023/12/11/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87%E9%87%8D%E7%BB%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title>Sumdiv</title>
    <url>/2023/12/12/Sumdiv/</url>
    <content><![CDATA[<p><a href> </a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>求 $A^B$ 的所有约数之和 $mod$ $9901$($1$ $\leq$ $A,B$ $\leq$ $5 * 10 ^ 7$)</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>将 $A$ 分解质因数，表示为 $p1^{c_1}$ <em> $p2 ^ {c_2}$ </em> …… <em> $pn^{c_n}$,那个 $A </em> B$ 就为 $p1^{B <em> c_1}$ </em> $p2 ^ {B <em> c_2}$ </em> …… <em> $pn^{B </em> c_n}$<br>根据乘法分配律， $A^B$ 所有约数的和就是：<br>($1 + p_1 + …… + p_1^{B <em> c_1}$) </em> ($1 + p_2 + …… + p_n^{B <em> c_2}$) </em> …… <em> ($1 + p_n + …… + p_n^{B </em> c_n}$)<br>比如：$360$ = $2^3<em>3^2</em>5^1$,约数之和为 $(2^0 + 2^1 + 2^2 + 2 ^ 3) <em> (3 ^ 0 + 3 ^ 1 + 3 ^ 2) </em> (5 ^ 0 + 5 ^ 1)$<br>约数个数为 $(3 + 1) <em> (2 + 1) </em> (1 + 1)$<br>每一个括号都是等比数列，使用分治法进行等比数列的求和。<br>问题转化为：<br>使用分治法求 sum(p,c) = $1 + p + p ^ 2 + …… + p ^ c$ = ?<br>若 $c$ 为奇数：sum(p,c) = (1 + $p^{c + 1}$) <em> sum(p,(c - 1) / 2);<br>若 $c$ 为偶数：sum(p,c) = (1 + $p ^ {c /2 }$) </em> sum(p,c / 2 - 1) + $p ^ c$;</p>
</blockquote>
<p>每一次分治之后，问题的规模会缩小一半，配合快速幂即可在 $O(log c)$ 的时间内求出等比数列的和。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1314</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">kmi</span><span class="params">(LL a,LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL ans = <span class="number">1</span>;</span><br><span class="line">    a %= MOD;</span><br><span class="line">	<span class="keyword">for</span>(;k ; k &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>)&#123;</span><br><span class="line">			ans = ans * a % MOD; </span><br><span class="line">		&#125;</span><br><span class="line">		a = a * a % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(LL p,LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(c &amp; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">return</span> (<span class="number">1</span> + <span class="built_in">kmi</span>(p,(c + <span class="number">1</span>) / <span class="number">2</span>) % MOD) * <span class="built_in">sum</span>(p,(c - <span class="number">1</span>) / <span class="number">2</span>) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">return</span> (<span class="number">1</span> + <span class="built_in">kmi</span>(p,c / <span class="number">2</span>)) % MOD * <span class="built_in">sum</span>(p,c / <span class="number">2</span> - <span class="number">1</span>)  % MOD+ <span class="built_in">kmi</span>(p,c) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;LL,LL&gt; cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL A,B;</span><br><span class="line">	cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= A / <span class="number">2</span> ; i ++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(A % i == <span class="number">0</span>)&#123;</span><br><span class="line">			A /= i;</span><br><span class="line">			cnt[i] ++; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(A &gt; <span class="number">1</span>) cnt[A] ++;</span><br><span class="line">	LL ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt)&#123;</span><br><span class="line">       <span class="comment">// cout &lt;&lt; x.first &lt;&lt; &#x27; &#x27; &lt;&lt; x.second &lt;&lt; endl;</span></span><br><span class="line">		ans *= <span class="built_in">sum</span>(x.first,x.second * B);</span><br><span class="line">		ans %= MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Strange Towers of Hanoi</title>
    <url>/2023/12/11/Strange-Towers-of-Hanoi/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><blockquote>
<p>解出 $n$ 个盒子 $4$ 座塔的汉诺塔问题最少需要多少次？</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>首先考虑 $n$ 个盒子 $3$ 座塔的经典汉诺塔问题，设 $d[n]$ 表示求解该 $n$ 题的最少步数，即把 $n - 1$ 个盒子从 $A$ 柱移动到 $B$ 柱，然后把第 $n$ 个盒子从 $A$ 柱移动到 $C$ 柱，然后把前 $n - 1$ 个盒子从 $B$ 柱移动到 $C$ 柱子。四塔模式下，转化为三塔模式，先移动 $i$ 个，移动到 $B$ 柱子，将 $n - i$ 个盒子移动到 $D$ 柱子，然后再把 $i$ 个盒子从 $B$ 柱移动到 $D$ 柱子。<strong>就是将四塔转化为三塔，运用三塔的思维来进行解题</strong></p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N],f[N];<span class="comment">//三层和四层汉诺塔</span></span><br><span class="line"><span class="comment">//三层汉诺塔 d[n] = 2 * d[n - 1] + 1;</span></span><br><span class="line"><span class="comment">//四层汉诺塔，转化为三层汉诺塔问题</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	d[<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">12</span>; i ++)&#123;</span><br><span class="line">        d[i] = <span class="number">2</span> * d[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">12</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i],<span class="number">2</span> * f[j]  + d[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; f[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>IncDec序列</title>
    <url>/2023/12/14/IncDec%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/102/"> —-&gt;传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2023/12/14/IncDec%E5%BA%8F%E5%88%97/image.png" alt></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>区间操作，可以考虑差分。观察发现，最终变成相同的数，相当于相邻的两个数之差为 $0$，因此我们使用差分。先求出差分数组 $b$,分别统计正数和负数的大小。我们有四种操作：</p>
<ol>
<li>$b_i$ 和 $b_j$，会改变 $(i,j)$ 内的大小</li>
<li>$b_1$ 和 $b_j$，会改变 $(1,j)$ 内的大小</li>
<li>$b_j$ 和 $b_{n + 1}$，会改变 $(j,n + 1)$ 内的大小</li>
<li>$b_1$ 和 $b_{n + 1}$ ，会改变整个数列的大小<br>可以肯定的是，第四种是无用功，操作是不会改变相对大小，为了让相对大小尽可能的改变，我们最优先才去第一种操作，在一定 <strong>区间内</strong> 的大小相同的时候，就考虑左端点和右边界的差值以及右端点和左边界的差值，进行 $2、3$ 操作。<br>统计可以得出，最小的操作次数为 $min(z,f) + \vert z - f\vert$，其中 $f$ 为负数的绝对值。<br>能产生 $\vert z - f\vert$ + 1 中不同的 $b_1$结果，即方案数。</li>
</ol>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6E5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>,<span class="title">b</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">	    cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>;  i--)&#123;</span><br><span class="line">	    b[i] = a[i] - a[i <span class="number">-1</span> ];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll z = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(b[i] &gt; <span class="number">0</span>) z += b[i];</span><br><span class="line">	    <span class="keyword">else</span> f += b[i];;</span><br><span class="line">	&#125;</span><br><span class="line">	f = -f;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(z,f) &lt;&lt; endl &lt;&lt; <span class="built_in">abs</span>(z - f) + <span class="number">1</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown常用公式收纳</title>
    <url>/2023/12/09/markdown%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E6%94%B6%E7%BA%B3/</url>
    <content><![CDATA[<p>此文章收集学习当中用到的markdown语法知识，旨在方便查找以及记忆</p>
<p>1.分数 \frac{}{}<br>2.绝对值(||) \vert \vert<br>3.上、下取整 \lceil \rceil \lfloor \rfloor </p>
]]></content>
      <categories>
        <category>字典</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>七夕祭</title>
    <url>/2024/01/03/%E4%B8%83%E5%A4%95%E7%A5%AD/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2024/01/03/%E4%B8%83%E5%A4%95%E7%A5%AD/image-8.png" alt></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>行的感兴趣的摊点或者列的感兴趣的摊点的数量能被行数或者列数整除，则能够实现要求。“均分”思想，设总感兴趣摊点数 $T$ 和行数列数 $n$，当前感兴趣的摊点数超过 $\frac{T}{n}$ 则将多余的感兴趣摊点数 $a_i - \frac{T}{n} $转移给旁边的；如果小于 $\frac{T}{n}$，则旁边向其转移 $\frac{T}{n}$ - $a_i$ 个。我们向每一行或每一列减去 $\frac{T}{n}$ ，最后前缀和得到的结果为 0，这个结果是等价的，那么我们就将最小转换次数的问题转化成求每个点到该点的距离总和最短。参考 “货仓选址”，中位数的性质可以得出结果。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bpt __builtin_popcountll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2E6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row[N], col[N];</span><br><span class="line">ll c[N];</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans = T / n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		c[i] = a[i] - ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> mid = c[n / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		sum += <span class="built_in">abs</span>(c[i] - mid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">		<span class="type">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		row[l] ++, col[r] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T % m &amp;&amp; T % n) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T % n) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;column&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>(col, m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T % m) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;row&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>(row, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;both&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>(row, n) + <span class="built_in">get</span>(col, m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>天才ACM</title>
    <url>/2024/01/10/%E5%A4%A9%E6%89%8DACM/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/111/"> 传送门 </a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2024/01/10/%E5%A4%A9%E6%89%8DACM/image.png" alt></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>简而言之倍增：设长度 len = 1，初始下标 start = 0，每一次累加这个区间长度的和，同时让区间长度 * 2,即sum + s[start + len] - s[start],start += len,len &lt;&lt;= 1;如果不满足某种特定条件,则缩小区间长度，len &gt;&gt;= 1;<br>本题在类似归并排序上进行倍增，只对新增的长度部分进行排序，然后合并新旧两段</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(NlogN)</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bpt __builtin_popcountll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2E6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="type">int</span> t[N], tmp[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sq</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span> * x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt; r; i++) &#123;</span><br><span class="line">		t[i] = w[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(t + mid, t + r);</span><br><span class="line">	<span class="type">int</span> i = l, j = mid, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i != mid &amp;&amp; j != r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t[i] &lt; t[j]) &#123;</span><br><span class="line">			tmp[k++] = t[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> tmp[k++] = t[j++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i != mid) tmp[k++] = t[i++];</span><br><span class="line">	<span class="keyword">while</span> (j != r) tmp[k++] = t[j++];</span><br><span class="line"></span><br><span class="line">	ll sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; i &lt; k; i++, k--) &#123;</span><br><span class="line">		sum += <span class="built_in">sq</span>(tmp[i] - tmp[k - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum &lt;= T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; w[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (end &lt; n)&#123;<span class="comment">//序列长度</span></span><br><span class="line">		len = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (len) &#123;<span class="comment">//区间长度最多为多少</span></span><br><span class="line">			<span class="keyword">if</span> (end + len &lt;= n &amp;&amp; <span class="built_in">check</span>(start, end, end + len)) &#123;</span><br><span class="line">				end += len;</span><br><span class="line">				len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (end &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">					t[i] = tmp[i - start];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		start = end;</span><br><span class="line">		ans++;<span class="comment">//每一次划分一个片段</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器</title>
    <url>/2023/12/18/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h3 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h3><p>随机存取存储器RAM，可以从任意选定的单元读取数据，或写入<br>在计算机中，RAM用作内存储器和高速缓存存储器<br>优点：快速读写，使用灵活；缺点：掉电丢失信息<br>静态RAM和动态RAM<br>静态RAM又分为 双极型和 MOS 型<br>烧制：击穿衬底，人为不能改变，又叫做出厂设置</p>
<p>固定只读存储器ROM，NMOS固定ROM 由厂家编辑<br>可编程只读存储器PROM 由用户编辑</p>
<p>可擦可编程只读存储器 浮栅技术，加载电压，形成沟道，聚集电子，形成导通，这个过程叫写入。一断电就恢复绝缘状态<br>光可擦除：$UVEPROM$ 电可擦除 $E^2PROM$等</p>
]]></content>
      <categories>
        <category>数字逻辑与数字系统</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>假期练习题汇总</title>
    <url>/2024/01/10/%E5%81%87%E6%9C%9F%E7%BB%83%E4%B9%A0%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>1.<a href="https://www.acwing.com/problem/content/111/">天才ACM </a><br>2.<a href="https://codeforces.com/problemset/problem/1916/C"> cf 1916C </a><br>3.<a href="https://codeforces.com/problemset/problem/1914/D"> cf 1914D </a><br>4.<a href="https://codeforces.com/problemset/problem/1903/B"> cf 1903B </a><br>5.<a href="https://codeforces.com/problemset/problem/1909/B"> cf 1909B </a><br>6 - 13 <a href="https://codeforces.com/contest/1914"> cf 916 div3</a><br>14 - 16 <a href="https://ac.nowcoder.com/acm/contest/73202"> 牛客练习赛120 A-C</a></p>
]]></content>
  </entry>
  <entry>
    <title>奇数码问题</title>
    <url>/2024/01/05/%E5%A5%87%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2024/01/05/%E5%A5%87%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/image.png" alt="Alt text"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>将二维转化为一维，求他的逆序对，如果逆序对的奇偶性相同，则能够实现。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bpt __builtin_popcountll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2E6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;l;<span class="comment">//大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; r;<span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N],c[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">merge</span>(l, mid, a);</span><br><span class="line">	<span class="built_in">merge</span>(mid + <span class="number">1</span>, r, a);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt;= mid &amp;&amp; a[i] &lt;= a[j] || j &gt; r) &#123;</span><br><span class="line">			b[k] = a[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cnt += mid - i + <span class="number">1</span>;</span><br><span class="line">			b[k] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">		a[k] = b[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">		<span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) ok = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> a[i - ok] = x;</span><br><span class="line">		&#125;</span><br><span class="line">		ok = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) ok = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> c[i - ok] = x;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">merge</span>(<span class="number">1</span>, n * n, a);</span><br><span class="line">		<span class="type">int</span> ans = cnt;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">merge</span>(<span class="number">1</span>, n * n, c);</span><br><span class="line">		<span class="keyword">if</span> ((ans &amp; <span class="number">1</span>) == (cnt &amp; <span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p>应用层：负责最直观的应用请求的封装、发起</p>
<h3 id="一、域名系统DNS"><a href="#一、域名系统DNS" class="headerlink" title="一、域名系统DNS"></a>一、域名系统DNS</h3><p>连接在互联网上的主机不仅有IP地址，还有便于用户记忆的主机名字。域名系统DNS能够把互联网上的主机的名字转换为IP地址</p>
<p>互联网采用层次树状结构的命名方式，任何一个连接在互联网上的主机，都有一个唯一的层次结构的名字，即域名。域名中的每一个层次叫做域，最高层次可以划分子域，每一个子域还可以继续划分子域，这样就形成了顶级域、二级域、三级域等<br>级别最低的域名写在最左边，级别最高的写在最右边，完整域名不超过255个字符，单个标号不超过63个字符标号由英文字母和数字组成，字符只能使用-</p>
<p>全球顶级域名</p>
<blockquote>
<p>按功能：国际通用顶级域名gTLD，国家顶级域名nTLD</p>
</blockquote>
<p>文件传输、访问和管理 FTP<br>电子邮件 SMTP POP3<br>虚拟终端 HTTP<br>查询服务和远程作业登录 DNS</p>
<p>互联网的域名空间结构<br><img src="/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/image.png" alt="Alt text"></p>
<p>从域名到IP地址的解析又多个域名服务器共同完成</p>
<p>域名系统不是以域为管理单位，而是以区为管理单位。区可能小于或等于域吗，但一定不能大于域，每一个区设置相应的权限域名服务器，保存区中所有主机的域名到IP的映射</p>
<p>(1) 根域名服务器：不管哪一个本地域名服务器，只要自己无法解析，首先求助于根域名服务器<br>(2) 顶级域名服务器：当收到DNS查询请求时，一般情况下会给出下一步应当找的权限域名服务器的IP地址<br>(3) 权限域名服务器：负责最终的域名到IP地址的解析<br>(4) 本地域名服务器：本地域名服务器也叫默认域名服务器，当一个主机发送DNS查询请求时，该查询请求报文就首先发给本地域名服务器，并且本地域名服务器会缓存其最近查询过的域名的解析，当所要查询的主机位于本地域名服务器的缓存中时，本地域名服务器就能立即将所查询的主机域名转化为它的IP地址，而不需要再去查询其他的域名服务器</p>
<p>为什么DNS支持UDP和TCP<br>大多数情况下DNS使用UDP进行传输，因为一般的返回的内容不会超过UDP报文的最大长度512字节，用UDP传输时，不需要经过TCP的三次握手的过程，从而提高了响应速度。因此这时也要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。但如果返回的响应超过512字节或者区域传送，会使用TCP进行传输</p>
<p>区域传送：主域名服务器向辅助域名服务器传送变化的那部分数据，一般很大。</p>
<p><strong>DNS的通信方式有UDP和TCP两种，端口都为53，一般情况下是UDP进行DNS域名查询，一般来说，UDP支持的最大数据受限于以太网帧的MTU1500字节，计算下来应该是1500 - 20 - 8 = 1472，但是怎么就变成了512了。是因为在非局域网环境，如：在internet下的时候，MTU是各个路由器进行一个配置的。所以通常路由器默认的MTU为576字节，所以为了适应网络环境，DNS协议在返回的数据大于512的时候，就转化为TCP协议</strong></p>
<h3 id="二、文件传送协议FTP"><a href="#二、文件传送协议FTP" class="headerlink" title="二、文件传送协议FTP"></a>二、文件传送协议FTP</h3><blockquote>
<p>使用TCP可靠的运输服务，最广泛的文件传送协议，使用客户-服务器方式，并且一个FTP服务器进程可同时为多个客户进程提供服务</p>
</blockquote>
<p>FTP的服务器进程由两部分组成：一个主进程，另外有若干个从属进程。</p>
<p>主进程打开端口，让外部发送的数据可以进来，并且将这些数据逐个分配给各从属进程。从属进程则是单独为这些数据服务<br>主进程工作步骤：<br>1.打开熟悉窗口（端口号21），等待客户进程发出连接请求<br>2.启动从属进程处理客户进程发送来的请求，处理完毕后即终止从属进程。<br>3.回到等待状态，继续接受其他客户进程发来的请求，主进程和从属进程的处理是并发进行的</p>
<p>根据数据连接是否是服务端主动建立，FTP有主动和被动两种<br>主动：服务器主动建立数据连接，服务器端口号位20，客户端的端口号随机，但必须大于1024，一位0-1023是熟知端口号<br>被动：客户端主动建立数据连接，其中客户端的端口号由客户端自己决定，服务器端的端口号随机</p>
<h3 id="三、万维网WWW"><a href="#三、万维网WWW" class="headerlink" title="三、万维网WWW"></a>三、万维网WWW</h3><blockquote>
<p>一个大规模的、联机式的信息储藏所</p>
</blockquote>
<p>能够非常方便的从互联网上的一个站点访问另外一个站点，从而主动的按需获取丰富的信息</p>
<p>万维网是一个分布式的超媒体系统，是超文本系统的扩充，而文本指的是包含指向其他文档的链接的文本</p>
<p>万维网的工作方式：</p>
<blockquote>
<p>客户-服务器方式工作，在万维网文档所驻留的主机上运行服务器程序，这个主机，这个主机也成为万维网服务器；在客户机上运行客户程序，万维网客户程序</p>
</blockquote>
<p>万维网需要解决的问题<br>怎样标志分布在整个互联网的万维网文档上的万维网文档</p>
<blockquote>
<p>使用统一资源定位符URL<br>使每一个文档在整个互联网的范围内具有唯一的标识符URL</p>
</blockquote>
<p>URL表示互联网上的资源的位置和访问这些资源的方法。URL实际上就是就是互联网资源的地址</p>
<p>URL的一般形式<br>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
<p>协议：ftp http https<br>主机：万维网文档所存放主机的域名，也可以使用IP地址，通常以WWW开头<br>端口：协议使用的端口号，使用默认的可以省略<br>路径：万维网文档所存放的目录</p>
<p>使用什么协议来实现万维网上的各种链接</p>
<blockquote>
<p>使用超文本传送协议HTTP<br>HTTP是一个应用层协议，使用TCP连接进行可靠的传送<br>HTTP定义了浏览器和万维网服务器通信的格式和规则</p>
</blockquote>
<p>TCP建立连接的三报文握手的第三个报文段可以携带数据，因此第三个报文段就是客户对万维网文档的请求报文。<strong>请求一个万维网文档所需的时间是该文档的传输时间(与文档大小成正比)加上两倍往返时间RTT(一个RTT用于建立TCP连接，另一个RTT用于请求和接受万维网文档)</strong></p>
<p><img src="/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/image-1.png" alt></p>
<p>非持续连接：</p>
<blockquote>
<p>HTTP/1.0 每请求一个文档都要有两倍RTT的开销，若一个页面与很多连接的对象需要依次进行链接，那么每一次链接下载都导致两倍的RTT的开销<br>在万维网服务器往往需要同时服务于大量客户的请求，这种非持续连接会使万维网服务器的负担很重</p>
</blockquote>
<p>持续连接：</p>
<blockquote>
<p>HTTP/1.1 使用持续连接；万维网服务器在发送响应后仍然在一段时间内保持这条TCP连接，使同一个客户和该服务器可以持续在这条连接上传送后续的HTTP 请求报文和响应报文，只要这些文档都在同一个服务器上就行</p>
</blockquote>
<p>持续连接有两种工作方式<br>(1)非流水线方式</p>
<blockquote>
<p>客户在收到前一个响应后才能发出下一个请求。在TCP连接建立后，客户每次访问对象都要去一个往返时间RTT，这比非持续连接要用两倍的RTT的开销，节省了建立TCP所需的一个RTT时间</p>
</blockquote>
<p>(2)流水线方式</p>
<blockquote>
<p>在收到HTTP响应报文之前能够接着发送新的请求报文，连续的多个请求报文到达服务器后，服务器就可持续发回响应报文<br>流水线工作方式使TCP连接中的空闲时间减少，提高了文档的下载效率</p>
</blockquote>
<p>并发TCP连接</p>
<blockquote>
<p>无论是持续连接还是非持续连接，浏览器都可以打开多个并行的TCP链接以提高访问速度</p>
</blockquote>
<p>HTTP/2.0</p>
<blockquote>
<p>允许客户复用TCP连接进行多个请求，这样就节省了大量的TCP链接多次建立和释放连接所花费的时间</p>
</blockquote>
<p>代理服务器</p>
<blockquote>
<p>网络硬件设备，万维网高速缓存，一般工作在中间系统上，以代理服务器方式构成的内容分发网络CDN 在互联网应用中起到了很大的作用</p>
</blockquote>
<p>简单来说，代理服务器就是把最近的一些请求和响应暂存在本地磁盘，当与暂时存放的请求相同的新请求到达时，代理服务器即返回暂存的响应，而不需要按URL去互联网访问该资源</p>
<p>没有代理服务器的情况下，当链路过载时，时延很大</p>
<p>使用代理服务器的情况<br>工作模式：<br>1.浏览器访问互联网的服务器时，先与校园网的代理服务器建立TCP连接，并向代理服务器发出HTTP请求报文。<br>2.若代理服务器已经存放了所请求的对象，则将此对象放入HTTP响应报文中返回给浏览器<br>3.若为存放，代理服务器就代表浏览器与互联网上的原点服务器建立TCP连接，并发送HTTP请求报文<br>4.源点服务器将所请求的对象放在HTTP 响应报文中返回给校园网的代理服务器<br>5.代理服务器收到对象后，先保存到本地缓存器，然后将该对象放在HTTP响应报文中，通过已经建立的TCP链接，返回个请求该对象但是浏览器</p>
<p>HTTP报文结构</p>
<blockquote>
<p>请求报文和响应报文</p>
</blockquote>
<p>组成</p>
<blockquote>
<p>开始行 区分请求还是响应报文<br>首部行 说明浏览器、服务器或报文主题的一些信息<br>实体主体 请求报文一般不用；响应报文一般是万维网文档，但也可不用</p>
</blockquote>
<p><img src="/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/image-2.png" alt></p>
<p>方法：对所请求的对象进行的操作，实际上是一些命令<br><img src="/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/image-3.png" alt></p>
<p><img src="/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/image-4.png" alt></p>
<p><img src="/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/image-5.png" alt></p>
<p>万维网站点使用Cookie来识别、跟踪用户</p>
<p>用户通过浏览器访问某一个网站，该网站的服务器会为其生成一个唯一的识别码，并且作为索引写入数据库当中，服务器会在响应报文的Set-cookie的首部行，写出赋予该用户的识别码。浏览器收到后会把服务器的主机名和识别码作为一项写入Cookie文件中，用户继续访问该网站的时候，每发送一个HTTP请求报文的时候，浏览器会从Cookie文件中取出该网站对于的识别码，放到HTTP请求报文的Cookie首部行中，利用次识别码，这个网站就能够跟踪该用户在该网站的活动(某音、宝等类似)。</p>
<p>使用超文本标记语言HTML可以使不同的作者创作不同的风格的万维网文档都能在互联网上的各种主机上显示出来，同时使用户清楚的知道在什么地方存在着连接</p>
<h3 id="四、电子邮件"><a href="#四、电子邮件" class="headerlink" title="四、电子邮件"></a>四、电子邮件</h3><blockquote>
<p>电子邮件系统由三个主要构建组成：用户代理、邮件服务器以及邮件发送协议和邮件读取协议</p>
</blockquote>
<p>用户代理：用户与电子邮件系统的接口，电子邮件客户端软件<br>邮件服务器：用来发送和接受邮件，同时还要向发送人报告邮件传送的结果<br>用户代理向邮件服务器发送邮件或邮件服务器之间发送邮件，使用简单邮件传送协议SMTP<br>用户代理从邮件服务器读取邮件时，使用邮局协议第三版 POP3</p>
<p>SMTP 和 POP3 都使用TCP连接来可靠的传送邮件，并且都使用客户-服务器的工作方式</p>
<p>基于万维网的电子邮件<br>电子邮件从浏览器发送到邮件服务器使用HTTP协议的POST方法<br>两个邮件服务器之间的传仍然使用SMTP协议<br>邮件从邮件服务器传送到浏览器使用HTTP协议的GET方法<br><img src="/2023/12/20/%E5%BA%94%E7%94%A8%E5%B1%82/image-6.png" alt></p>
<p>通用互联网邮件扩充 MIME<br>SMTP不能传送可执行文件或其他二进制文件，只能传送7位的ASCII文本文件，所以需要MIME对邮件内容进行内容的格式转换</p>
<h3 id="五、动态主机配置协议DHCP"><a href="#五、动态主机配置协议DHCP" class="headerlink" title="五、动态主机配置协议DHCP"></a>五、动态主机配置协议DHCP</h3><p>连接到互联网的计算机的协议软件需要配置以下项目：<br>IP地址 子网掩码 默认路由器IP地址(默认网关)  域名服务器的IP地址</p>
<p>不可能一直都是人工手动配置，因此动态主机配置协议DHCP(即插即用的连网方式)，允许主机自动获取以上配置信息而不需要手工干预</p>
<p>使用客户-服务器方式</p>
<p>(1)需要IP地址的主机在启动时广播发送报文，将目的IP地址设为255:255:255:255，这时该主机就成为DHCP客户，发送广播报文是因为不知道DHCP服务器在什么地方，因此要发现DHCP服务器的IP地址，这台主机目前还没有自己的IP地址，因此它将IP数据报的源IP地址设为0<br>(2)本地网络上的所有主机都能够收到这广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器的IP地址池中取一个地址分配给计算机。DHCP服务器使用提供报文将配置信息返回给请求方</p>
<p>DHCP中继代理</p>
<blockquote>
<p>广播发送的发现报文无法跨网络传输，而在每一个网络中设置一个DHCP服务器又会使DHCP服务器的数量太多，因此需要在每一个网络中至少部署一个DHCP中继代理，而路由器太多具有中继代理功能，它配置了DHCP服务器的IP地址信息<br>然后，当DHCP中继代理收到主机以广播形式发送的发现报文后，就以单播的形式向DHCP服务器转发此报文，并等待回答，收到DHCP服务器回答的提供报文后，DHCP中继代理再把此提供报文发回给主机</p>
</blockquote>
<p>租用期</p>
<blockquote>
<p>DHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在一段时间内使用，其值可在DHCP服务器中设定</p>
</blockquote>
<p>DHCP服务器在给DHCP客户发送的提供报文的选项中给出租用期的数值，过半1，DHCP客户需要发送请求报文更新租用期</p>
<p>1.DHCP服务器被动打开UDP端口67，等待客户端发来的报文<br>2.DHCP客户从UDP端口68发送报文<br>3.凡收到DHCP发现报文的DHCP服务器都发出DHCP提供报文，因此DHCP客户可能收到多个DHCP提供报文<br>4.DHCP客户从几个DHCP服务器中选择一个，并向其发送DHCP请求报文<br>5.被选择的DHCP服务器发送确认报文，DHCP客户收到确认报文后就可以使用这个IP地址了<br>6.DHCP客户现在要根据服务器提供的租用期T设置两个计时器T1和T2，他们的超时时间分别是0.5T和0.875T<br>7.租用期过半(T1时间到),DHCP客户发送请求报文，要求更新租用期<br>8.若DHCP服务器同意，则发回确认报文，DHCP客户得到了新的租用期，需要重新设置计时器<br>9.若DHCP服务器不同意，则发回否认报文，这是DHCP客户必须立即停止使用原来的IP地址，而必须重新申请IP地址(回到步骤2)</p>
<p>DHCP客户可随时终止服务器所提供的租用期，这时只需要向DHCP服务器发送释放报文即可</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>http和DNS协议</title>
    <url>/2023/12/11/http%E5%92%8CDNS%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p><img src="http和DNS协议/image.png" alt></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>拥塞控制</title>
    <url>/2023/12/19/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>检查是否发生拥塞：记录超时重传的包的数目<br>拥塞窗口cwnd： 控制发送报文速率的一个状态变量<br>接收方能不能及时接收一定的数量报文</p>
<p>大小随着网络的拥塞程度动态变化<br>没有拥塞，增大拥塞窗口，发送更多的报文<br>出现拥塞，减小窗口<br>假定足够大，发送窗口等于拥塞窗口的数值</p>
<p>流量窗口：接收端根据接受能力调整，字节为单位<br>发送窗口：发送方根据拥塞状态调整 报文段MSS单位<br>与发送和接受双方没用关系，取决于这个路上的网络的拥塞状态</p>
<p>cwnd很小初始，为1，慢开始算法<br>若没有拥塞，增大拥塞窗口，提高发送效率<br>cwnd较小，指数增长，较大，线性增长，拥塞避免算法</p>
<p>若出现拥塞，减小拥塞窗口，消除拥塞<br>调整门限 乘法减小</p>
<p>传输轮次：一个轮次传输一个拥塞窗口的数据</p>
<p>提高效率；快重传和快恢复<br>快重传：连续三个重复确认发送给发送方</p>
<p>窗口<br>256 39 （38 36） </p>
<p>报文长度不一定相同</p>
<p>254 22、（23、24）<br>207 48 47 45 46<br>208 63<br>205 37 26 31 33<br>204 20 21 19<br>路由器路由表怎么写<br>112 7 8 33 30<br>求时延<br>RRT</p>
<p>没有选择没有填空，全是大题<br>第一章 网络性能指标概述 两个题 20<br>第三章 20分 计算题 简单题 应用题<br>第四章 六道题 60分</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>最佳牛围栏</title>
    <url>/2023/12/17/%E6%9C%80%E4%BD%B3%E7%89%9B%E5%9B%B4%E6%A0%8F/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/104/"> —-&gt; 传送门 </a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>给定正整数序列 $A$，求一个平均数最大的、长度不小于 $L$ (连续的) 字段。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>二分答案。判定“是否存在一个长度不小于 $L$ 的字段，平均数不小于二分的值”<br>如果数列的每个数都减去二分的值，就转化为判定“是否存在一个长度不小于 $L$ 的字段，字段和非负”。<br>接下来解决两个问题：<br>1.求一个字段，他的和最大(无长度限制)<br>扫描该数列，字段和变成负数 ，则清空。<br>2.求一个字段，他的和最大(长度不小于 $L$)<br>每一次只会有一个新的取值需要进行比较，因此只需要用一个变量记录一下当前的最小值，每次新的取值与最小值比较。</p>
<p><strong>单调性</strong>：答案随着某个变量增大而增大或者增大而减小。</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>$nlogn$</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3></blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6E5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a[N],b[N],sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> N,L;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; L;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= N; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> l = <span class="number">-1e6</span>,r = <span class="number">1e6</span>;</span><br><span class="line">	<span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line">	<span class="keyword">while</span>(r - eps &gt; l)&#123;</span><br><span class="line">		<span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">			b[i] = a[i] - mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">			sum[i] = (sum[i - <span class="number">1</span>] + b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">double</span> ans = <span class="number">-1e10</span>;</span><br><span class="line">		<span class="type">double</span> min_val = <span class="number">1e10</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = L; i &lt;= N; i ++)&#123;</span><br><span class="line">			min_val = <span class="built_in">min</span>(min_val,sum[i-L]);<span class="comment">//</span></span><br><span class="line">			ans = <span class="built_in">max</span>(ans,sum[i] - min_val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">if</span>(ans &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			l = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">int</span>(r * <span class="number">1000</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客攻略</title>
    <url>/2023/12/07/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>从大一开始就一直想搭建自己的一个博客网站，但是直到现在才付诸行动，以此篇文章纪念一下。</p>
<h2 id="一、下载-git-和-Node-js"><a href="#一、下载-git-和-Node-js" class="headerlink" title="一、下载$git$ 和 $Node.js$"></a>一、下载$git$ 和 $Node.js$</h2><p><a href="https://nodejs.org/en/"> $Node.js$ 传送门</a></p>
<p><a href="https://git-scm.com/"> $git$ 传送门</a></p>
<h2 id="二、安装-hexo"><a href="#二、安装-hexo" class="headerlink" title="二、安装$hexo$"></a>二、安装$hexo$</h2><h3 id="1-在非-C-盘新建一个文件夹-blog-，右键打开-git-bash"><a href="#1-在非-C-盘新建一个文件夹-blog-，右键打开-git-bash" class="headerlink" title="$1.$在非 $C$ 盘新建一个文件夹 $blog$，右键打开 $git bash$"></a>$1.$在非 $C$ 盘新建一个文件夹 $blog$，右键打开 $git bash$</h3><p><img src="/2023/12/07/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/image.png" alt></p>
<p>输入</p>
<blockquote>
<p>npm install hexo-cli -g<br>npm install hexo-deployer-git —save//部署插件，hexo d需要用到</p>
</blockquote>
<h3 id="2-在-git-创建文件-hexo"><a href="#2-在-git-创建文件-hexo" class="headerlink" title="$2.$在 $git$ 创建文件 hexo"></a>$2.$在 $git$ 创建文件 hexo</h3><blockquote>
<p>mkdir hexo</p>
</blockquote>
<h3 id="3-hexo初始化"><a href="#3-hexo初始化" class="headerlink" title="$3.$hexo初始化"></a>$3.$hexo初始化</h3><blockquote>
<p>hexo init</p>
</blockquote>
<h3 id="4-在-vscode-打开文件-hexo-的-config"><a href="#4-在-vscode-打开文件-hexo-的-config" class="headerlink" title="$4.$在 $vscode$ 打开文件 $hexo$ 的 $_config$"></a>$4.$在 $vscode$ 打开文件 $hexo$ 的 $_config$</h3><p><img src="/2023/12/07/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/image-1.png" alt></p>
<h3 id="5-打开-config-，划到最下面，修改-repo"><a href="#5-打开-config-，划到最下面，修改-repo" class="headerlink" title="$5.$打开 _$config$，划到最下面，修改 $repo$"></a>$5.$打开 _$config$，划到最下面，修改 $repo$</h3><blockquote>
<p>deploy:<br>  type: ‘’<br>  repo: git@github.com:你的用户名/你的用户名.github.io.git<br>  branch: master</p>
</blockquote>
<h3 id="6-右键-hexo-文件用-git-打开，输入"><a href="#6-右键-hexo-文件用-git-打开，输入" class="headerlink" title="$6.$右键 $hexo$ 文件用 $git$ 打开，输入"></a>$6.$右键 $hexo$ 文件用 $git$ 打开，输入</h3><blockquote>
<p>hexo s</p>
</blockquote>
<p>本地加载完成<br><img src="/2023/12/07/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/image-2.png" alt></p>
<h2 id="三、配置-git"><a href="#三、配置-git" class="headerlink" title="三、配置 $git$"></a>三、配置 $git$</h2><h3 id="1-在-git-新建库，注意格式"><a href="#1-在-git-新建库，注意格式" class="headerlink" title="$1.$在 $git$ 新建库，注意格式"></a>$1.$在 $git$ 新建库，注意格式</h3><p><img src="/2023/12/07/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/image-4.png" alt></p>
<p>命名成</p>
<blockquote>
<p>你的用户名.github.io</p>
<h3 id="2-然后在-git-上输入"><a href="#2-然后在-git-上输入" class="headerlink" title="$2.$然后在 $git$ 上输入"></a>$2.$然后在 $git$ 上输入</h3><p>git config —global user.name “你的Github用户名”<br>git config —global user.email “你的Github邮箱”</p>
</blockquote>
<h3 id="3-生成密钥"><a href="#3-生成密钥" class="headerlink" title="$3.$生成密钥"></a>$3.$生成密钥</h3><blockquote>
<p>ssh-keygen -t rsa -C “你的Github邮箱”</p>
</blockquote>
<h3 id="4-查看密钥"><a href="#4-查看密钥" class="headerlink" title="$4.$查看密钥"></a>$4.$查看密钥</h3><blockquote>
<p>cat ~/.ssh/id_rsa.pub</p>
</blockquote>
<h3 id="5-复制粘贴到-github-里的-SSH"><a href="#5-复制粘贴到-github-里的-SSH" class="headerlink" title="$5.$复制粘贴到 $github$ 里的 $SSH$"></a>$5.$复制粘贴到 $github$ 里的 $SSH$</h3><p><img src="/2023/12/07/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/image-3.png" alt></p>
<h3 id="6-建立连接"><a href="#6-建立连接" class="headerlink" title="$6.$建立连接"></a>$6.$建立连接</h3><blockquote>
<p>ssh -T git@github.com</p>
</blockquote>
<p>出现 </p>
<blockquote>
<p>Hi xxx! You’ve successfully authenticated…</p>
</blockquote>
<p>则成功链接</p>
<h3 id="7-在hexo打开的-git-上输入"><a href="#7-在hexo打开的-git-上输入" class="headerlink" title="$7.$在hexo打开的 $git$ 上输入"></a>$7.$在hexo打开的 $git$ 上输入</h3><blockquote>
<p>hexo clean<br>hexo g<br>hexo d<br>出现如图<br><img src="/2023/12/07/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%94%BB%E7%95%A5/image-5.png" alt></p>
</blockquote>
<p>等待一会，博客建立</p>
]]></content>
      <categories>
        <category>技术开发搭建</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>激光炸弹</title>
    <url>/2023/12/14/%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>$—&gt;$ <a href="https://www.acwing.com/problem/content/description/101/"> 传送门</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><img src="/2023/12/14/%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/image.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="/2023/12/14/%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/图解.png" alt><br><img src="/2023/12/14/%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9/图解2.png" alt></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bpt __builtin_popcountll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> +<span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,R;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; R;</span><br><span class="line">    R = <span class="built_in">min</span>(R,<span class="number">5001</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;  i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        g[++x][++y] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5001</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5001</span>; j ++)&#123;</span><br><span class="line">            g[i][j] = g[i<span class="number">-1</span>][j] +g[i][j - <span class="number">1</span>] - g[i<span class="number">-1</span>][j<span class="number">-1</span>] + g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = R ; i &lt;= <span class="number">5001</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j  = R ; j &lt;= <span class="number">5001</span>; j ++)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,g[i][j] - g[i-R][j] - g[i][j - R] + g[i - R][j - R]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊排序</title>
    <url>/2023/12/17/%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2023/12/17/%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F/image.png" alt></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>交互：不知道大小关系，只能通过调用compare接口询问<br>根据数学归纳法，假设前 $k -1$ 个元素已经按要求排成一行，如果能确定第 $k$ 个元素应该放在哪一个前面，即可解决该问题<br>通过二分确定这个位置。若第 $k$ 个元素比第 $mid$ 个元素小，令 $r = mid$,否则 $l = mid + 1$。</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>不超过 NlogN</p>
</blockquote>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">specialSort</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= N;i++)&#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = res.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">compare</span>(res[mid],i)) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = res.<span class="built_in">size</span>() - <span class="number">2</span>;j &gt; r;j--)   <span class="built_in">swap</span>(res[j],res[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>最高的牛</title>
    <url>/2023/12/14/%E6%9C%80%E9%AB%98%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/103/"> —-&gt;传送门 </a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="\最高的牛/image.png" alt></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目中的 $M$ 对关系给我们的信息实际上是牛之间身高的相对大小的关系，我们初始化一个数组 $a$，全部为 $0$，有一对关系内，我们就可以得知在 $(l,r)$ 内的牛要比端点矮，通过差分来映射出这个关系，我这个范围内的牛要比端点的至少低 $1$，最后每个牛的身高就是最高值与相对大小之和，即 $h + a[i]$。</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>将区间操作转化了左右端点上的操作，时间复杂度为 O(N + M)。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bpt __builtin_popcountll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6E5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,p,h,m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">2</span>);</span><br><span class="line">	map&lt;PII,<span class="type">int</span>&gt; mp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">	    <span class="type">int</span> l,r;</span><br><span class="line">	    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">	    <span class="keyword">if</span>(l &gt; r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">	    <span class="keyword">if</span>(mp[&#123;l,r&#125;]) <span class="keyword">continue</span>;</span><br><span class="line">	    mp[&#123;l,r&#125;] = <span class="number">1</span>;</span><br><span class="line">	    a[l + <span class="number">1</span>] --,a[r] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	    a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	    cout &lt;&lt; h + a[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>最短Hamilton路径</title>
    <url>/2023/12/10/%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/93/"> —-&gt; 传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>给定一张 $n$ 个点的带权无向图，点从 $0∼n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 $Hamilton$ 路径。$Hamilton$ 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>暴力超时，所以考虑二进制、状态压缩等思路。在 $1 &lt;&lt; n$ 的范围内的每一个数的二进制都是一种选择方案。$0$ 表示未到达， $1$ 表示到达，枚举每一种方案中每一个点到达情况的状态转移。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][<span class="number">22</span>],weight[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; weight[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;<span class="comment">//多少种方案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//到达哪个点</span></span><br><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; j &amp; <span class="number">1</span>)) &#123;<span class="comment">//是否为 1，1则表示这个点已经走过</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;<span class="comment">//枚举哪些点到达 j, i -&gt; j --- k -&gt; j</span></span><br><span class="line">                    <span class="keyword">if</span> (i ^ (<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>) &#123;<span class="comment">//同理，找没到达j点的情况，从k走到j 1 ^ 1 = 0，将第j位变为0</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i ^ (<span class="number">1</span> &lt;&lt; j)][k] + weight[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>二进制状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>白华</title>
    <url>/2023/12/06/%E7%99%BD%E5%8D%8E/</url>
    <content><![CDATA[<p>以我的笔名<br>叙述新开始</p>
]]></content>
  </entry>
  <entry>
    <title>牛客练习赛120A-C</title>
    <url>/2024/01/13/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B120A-C/</url>
    <content><![CDATA[<h2 id="A-抽奖黑幕"><a href="#A-抽奖黑幕" class="headerlink" title=" A.抽奖黑幕"></a><a href="https://ac.nowcoder.com/acm/contest/73202/A"> A.抽奖黑幕</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>给出一个序列，已经确定了 $n - 1$ 个元素，求能够使序列去除一个最大值和一个最小值之后的总和最大的最小值正整数 $a_n$</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>观察发现，分两种情况，第一种是整个序列元素大小是一样的，这个时候我们取 $1$ 是最优解；第二种情况是，不完全一样，这个时候就选择最大值即可，保留一个最大值，最小值和原来的最大值就去除，最优</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)  cin &gt;&gt; a[i];</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i - <span class="number">1</span>] != a[i]) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) x = <span class="built_in">max</span>(x, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="B-生成函数"><a href="#B-生成函数" class="headerlink" title=" B.生成函数"></a><a href="https://ac.nowcoder.com/acm/contest/73202/B"> B.生成函数</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>三种无限的砝码一个一个物品 $m$,问能否通过放置砝码使得天平平衡。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>砝码左右都可以加，只要最终保证天平平衡即可，那么就需要保证，这几个数的最大公约数能够被物品 $m$ 整除</p>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b, c, m;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; m;</span><br><span class="line">	<span class="type">int</span> aa = <span class="built_in">abs</span>(a - b), bb = <span class="built_in">abs</span>(b - c);</span><br><span class="line">	<span class="type">int</span> GCD = <span class="built_in">gcd</span>(aa,bb );</span><br><span class="line">	GCD = <span class="built_in">gcd</span>(a, GCD);</span><br><span class="line">	GCD = <span class="built_in">gcd</span>(b, GCD);</span><br><span class="line">	GCD = <span class="built_in">gcd</span>(c, GCD);</span><br><span class="line">	<span class="keyword">if</span> (m % GCD) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-选择交换"><a href="#C-选择交换" class="headerlink" title=" C.选择交换"></a><a href="https://ac.nowcoder.com/acm/contest/73202/C"> C.选择交换</a></h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>给出一个序列，交换位置使得序列满足<br>$a_1 + a_n = a_2 + a_{n - 1} …… = a_{\frac{n}{2}}  + a_{n + 1 - \frac{n}{2}}$</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>将序列的值和下标绑定，动态维护交换序列。找出序列大小的平衡值，如果奇数序列中间的元素不满足平衡值，则是不合法的序列，同时当循环中发现对应的元素不满足平衡值，也是不合法的序列。剩余情况均合法，则动态维护序列，求得下标交换过程</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3></blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PII a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(PII A,PII B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.fi &lt; B.fi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> v; cin &gt;&gt; v;</span><br><span class="line">		a[i] = &#123; v,i &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>,cmp);</span><br><span class="line">	ll var = a[<span class="number">1</span>].fi + a[n].fi;</span><br><span class="line">	<span class="comment">//判断有没有解</span></span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[n / <span class="number">2</span> + <span class="number">1</span>].fi * <span class="number">2</span> != var) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i].fi + a[n - i + <span class="number">1</span>].fi !=  var) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//合理的</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;PII&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[i].se != i) &#123;</span><br><span class="line">			vec.<span class="built_in">pb</span>(&#123; a[i].se,i &#125;);</span><br><span class="line">			<span class="built_in">swap</span>(a[i].se,a[a[i].se].se);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : vec) &#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>vp</tag>
      </tags>
  </entry>
  <entry>
    <title>移位运算</title>
    <url>/2023/12/10/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="a-b"><a href="#a-b" class="headerlink" title=" a ^ b"></a><a href="https://www.acwing.com/problem/content/91/"> a ^ b</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>在 $a$ 的 $b$ 次方对 $p$ 取模，其中 $1 \leq a,b,p \leq 10 ^ 9$</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>根据数学常识，<strong>每一个正整数都可以为一的表示为若干指数不重复的 $2$ 的次幂的和</strong>。$b = c_{k-1}2^{k-1} + c_{k-2}2^{k-2} + …… + c_02^0$。$c_i$ 表示在二进制下 $b$ 的第 $i$ 位是 $0$ 还是 $1$。</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>因为 $k = \lceil log(b + 1) \rceil$ ,通过 $k$ 次递推出每一个乘积项，因此整个算法的时间复杂度为 $log_2b$。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,p;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	LL ans = <span class="number">1</span> % p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>( ; b; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">			ans = (LL)ans * a % p;<span class="comment">// a ^ b </span></span><br><span class="line">		&#125;</span><br><span class="line">		a = (LL)a * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title=" 64位整数乘法 "></a><a href="https://www.acwing.com/problem/content/92/"> 64位整数乘法 </a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>求 $a$ 乘 $b$ 对 $p$ 的取模，其中 $1 \leq a,b,p \leq 10 ^ {18}$</p>
</blockquote>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 $1$"></a>解法 $1$</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><blockquote>
<p>类似于快速幂的思想，把整数 $b$ 用二进制表示<br>$b$ = $c_{k-1}2^{k-1}$ + $c_{k-2}2^{k-2}$ + …… + $c_02^0$，则 a * b = a * $(c_{k-1}2^{k-1} + c_{k-2}2^{k-2} + …… + c_02^0)$    。</p>
</blockquote>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL a,b,p;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; b; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">			ans = (ans + a) % p;</span><br><span class="line">		&#125;</span><br><span class="line">		a = a * <span class="number">2</span> % p;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 $2$"></a>解法 $2$</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><blockquote>
<p>利用 $a$ * $b$ mod $p$ = $a$ * $b$ - $\lfloor$ $a$ * $b$ / $p$ $\rfloor$ * $p$。在 $a$ * $b$ / $p$ 中我们可以用浮点数来执行，因为浮点数的在十进制下的有效数字有 $18$ 、 $19$ 位(因为相除之后会变成小数点后的位数，足够存储)，足够胜任。</p>
</blockquote>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL a,b,p;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	a %= p,b %= p;</span><br><span class="line">	LL c = (<span class="type">long</span> <span class="type">double</span>)a * b / p;</span><br><span class="line">	LL ans = a * b - c * p;</span><br><span class="line">	<span class="keyword">if</span>(ans &lt; <span class="number">0</span>) ans += p;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ans &gt;= p)ans -= p;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>位运算 数学</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/2024/01/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2023/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>第一章 基础算法</title>
    <url>/2023/12/09/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>该篇主要做知识点总结，代码和题目在其他文章当中</p>
<h1 id="一-位运算"><a href="#一-位运算" class="headerlink" title="一.位运算"></a>一.位运算</h1><h2 id="1-算术位运算"><a href="#1-算术位运算" class="headerlink" title="1.算术位运算"></a>1.算术位运算</h2><blockquote>
<p>与 and &amp;<br>非 not ~<br>或 or |<br>异或 xor ^</p>
</blockquote>
<h2 id="2-补码"><a href="#2-补码" class="headerlink" title="2.补码"></a>2.补码</h2><p> $32$ 位有符号整数 $int$<br> $32$ 位无符号整数 $unsigned$ </p>
<p>$int$ 溢出为负数的原因：最高位是符号位，溢出的数会使最高位为 $1$,这个 $1$表示负数。</p>
<p>正数的补码是本身<br>负数的补码是反码 + 1</p>
<p>正数的反码是本身<br>负数的反码是取反</p>
<h2 id="3-移位换算"><a href="#3-移位换算" class="headerlink" title="3.移位换算"></a>3.移位换算</h2><p>算术左移：左移，低位以 $0$ 填充，高位越界舍弃</p>
<p>$1 &lt;&lt; n = 2 ^ n$ <br><br>$n &lt;&lt;  2n$</p>
<p>算术右移：右移，高位以符号位填充，低位越界舍弃<br>$n &gt;&gt; 1 = \vert \frac{n}{2.0}\vert$</p>
<h2 id="4-二进制状态压缩"><a href="#4-二进制状态压缩" class="headerlink" title="4.二进制状态压缩"></a>4.二进制状态压缩</h2><p>1.可以使用一个 $n$ 位的二进制数来表示在任意时刻哪些点走过，哪些点没走过。第 $i$ 位为 $1$ 表示已经走过。<br>题型：二进制状态压缩、状压dp</p>
<p>2.位运算的主要特点之一就是二进制不进位，换言之，二进制下的每一位的运算是独立的，两个数的二进制第 $i$ 位的运算结果只取决于两个数的第 $i$ 位<br>因此我们可以通过这个性质造数字，在什么条件下满足这个范围内最大的数字是多少。我称之为填数字，在一定位数的二进制数下，填 $1$ 还是填 $0$ 是最优的</p>
<h1 id="二-递推和递归"><a href="#二-递推和递归" class="headerlink" title="二.递推和递归"></a>二.递推和递归</h1>]]></content>
      <categories>
        <category>基础算法章节总结</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2023/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>计算机网络：利用通信线路和交换设备将地理位置分散的、具有独立功能的多台计算机连接起来，按照某种协议进行数据通信、实现资源共享的信息系统<br>资源共享：软件、硬件、数据<br>核心部分：通信线路和交换设备<br>边缘部分：独立功能的多台计算机<br><img src="\计算机网络概述/image.png" alt></p>
<p>主机A与主机B通信，实际上就是指：进程与进程进行的通信。</p>
<p>主机之间的两者通信方式：<br>1.C/S 客户/服务器方式<br>描述的是进程之间服务与被服务的关系<br>2.P2P 对等连接方式<br>不区分服务请求方和提供方，运行P2P软件，进行对等连接通信，本质上双方都是客户又是服务器</p>
<p>计算机网络分类<br>1.分布范围：广域网WAM 跨国，城域网MAN 城市范围，局域网LAN 一个教学楼等，个域网PAN 个人几米范围之内<br>2.使用者：公用网 专用网<br>3.拓扑结构 总线型 星型 环型 网状型<br>4.数据交换：电路交换 报文交换 分组交换<br>报文交换和分组交换都是存储转发方式（先存再发）</p>
<p>电路交换：通话全部时间，两个用户始终占用端到端的通信资源<br>缺点：通信线路利用率低</p>
<p>报文：要发送的整块数据称为一个报文</p>
<p>报文交换是整个报文到下一个路由器存储再进行转发，而分组交换是，报文的一个数据段，包，每一个都独立进行存储和转发<br>分层体系结构</p>
<p>OSI参考模型<br>实体：每一个层次就叫一个实体<br>协议：这一层次应该遵守哪些规则<br>下层为上层提供服务</p>
<p>互联网服务提供者 ISP<br>所谓的上网，就是通过某ISP 获取所需的IP地址，以通过该ISP接入互联网</p>
<p>计算机网络的性能(重点)<br>1.速率</p>
<blockquote>
<p>数据的传送速率，又叫数据率或者比特率。提到网络的速率时，往往指的是额定速率或标称速率<br>单位为 bit/s b/s bps<br>数据率一般是 B KB MB<br>速率一般是 b/s kb/s Mb/s</p>
</blockquote>
<p>2.带宽</p>
<blockquote>
<p>有两种含义，第一种是，某个信号具有的频带宽度，即占据的频率范围单位是赫兹，<strong>某信道允许通过的信号频率范围称为该信道的带宽</strong><br>第二种含义是， <strong>在计算机网络中，带宽用来表示在单位时间内网络中的某信道所能通过的“最高数据率”</strong>，表示某通道传送数据的能力，单位为 bit/s</p>
</blockquote>
<p>小写单位是1000，大写单位是1024</p>
<p>3.吞吐量</p>
<blockquote>
<p>表示在单位时间内通过某个网络（信道、接口）的实际数据量<br>受网络的带宽或网络的额定速率限制</p>
</blockquote>
<p>4.时延</p>
<blockquote>
<p>数据（一个报文或分组甚至比特）从网络或链路的一端传送到另一端所需的时间</p>
</blockquote>
<p>主要有四部分组成：<br>(1).发送时延 </p>
<blockquote>
<p>主机或路由器发送数据所需要的时间，也就是从发送数据的第一个比特算起，到发完该数据的最后一个比特为止所需的时间<br>计算公式：$\frac{数据帧长度(bit)}{发送速率(bit/s)}$</p>
</blockquote>
<p>(2).传输时延</p>
<blockquote>
<p>是电磁波在信道中传播一定距离需要花费的时间。<br>计算公式：$\frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}$</p>
</blockquote>
<p>(3).处理时延<br>(4).排队时延</p>
<p><img src="/2023/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-1.png" alt></p>
<p>总时延 = 发送 + 传播 + 处理 + 排队</p>
<p>5.时延带宽积</p>
<blockquote>
<p>传播时延和带宽相乘<br>链路的时延带宽积表示这样的链路可以容纳多少个比特</p>
</blockquote>
<p><img src="/2023/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/image-2.png" alt></p>
<p>6.往返时间RTT</p>
<blockquote>
<p>从发送方发送完数据到发送方收到接收方的确认所经过的时间，双向交互一次的时间</p>
</blockquote>
<p>有效数据率 = $\frac{数据长度}{发送时间+RTT}$</p>
<p>7.利用率</p>
<blockquote>
<p>信道利用率和网络利用率</p>
</blockquote>
<p>(1).信道利用率</p>
<blockquote>
<p>某信道有百分之几的时间是被利用的<br>完全空闲的信道的利用率是0</p>
</blockquote>
<p>(2).网络利用率</p>
<blockquote>
<p>全网络的信道利用率的加权平均值</p>
</blockquote>
<p>网络当前的时延 = $\frac{网络空闲的时延}{1 - 网络当前的利用率}$</p>
<p>当信道利用率增大时，引起的时延迅速增大。</p>
<p>信道利用率或网络利用率过高就会产生非常大的时延，因此一般要控制信道利用率不超过50%，如果超过了，就要准备扩容，增大线路的宽度</p>
<p>丢包率</p>
<blockquote>
<p>分组丢失率，在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率</p>
</blockquote>
<p>计算机网络的非性能特征<br>1.费用 2.质量 3.标准化 4.可靠性 5.可扩展性和可升级性 6.易于管理和维护等</p>
<p>计算机网络体系结构<br>五层协议的体系结构<br>(1).应用层</p>
<blockquote>
<p>通过应用进程的交互来完成特定网络应用<br>交互的数据单元：报文<br>常用协议：域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议</p>
</blockquote>
<p><strong>应用层协议定义的是应用进程间通信和交互的规则，对于不同的网络应用需要有不同的应用层协议</strong></p>
<p>(2).运输层</p>
<blockquote>
<p>为两台主机中进程之间的通信提供通用的数据传输服务(通用：多种应用可以使用同一个运输层服务)<br>复用：多个应用层可同时使用下面运输层的服务<br>分用：运输层把收到的信息分别交付上面的应用层中的相应过程<br>主要协议：传输控制协议TCP(提供面向连接的、可靠的数据传输服务，其数据传输的单元是报文段)<br>用户数据报协议UDP(提供无连接的尽最大努力的数据传输服务，但不保证数据传输的可靠性，其数据传输的单元是用户数据报)</p>
</blockquote>
<p><strong>报文段通常指起始点和目的地都是传输层的信息单元，数据报指面向无连接的数据传输，分别对于TCP和UDP，艺可称他们为数据段</strong></p>
<p>(3).网络层</p>
<blockquote>
<p>负责为分组交换网上的不同主机提供通信服务<br>数据单元：分组或数据报<br>常用协议：忘记协议IP和许多路由选择协议</p>
</blockquote>
<p>(4).数据链路层</p>
<blockquote>
<p>在两个相邻的节点之间传送数据帧(将网络层下来的IP数据报组装成帧，每一帧包括数据和必要的控制信息)。<br>常用协议：PPP、CSMA/CD等<br>如发现错误，就简单的丢弃出错的帧</p>
</blockquote>
<p>(5).物理层</p>
<blockquote>
<p>任务：实现比特(0/1)的传输<br>数据单元：比特</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>费解的开关</title>
    <url>/2023/12/11/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/998/D"> —-&gt; 传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2023/12/11/%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/IMG.png" alt></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>1.每个位置至多只会被点击一次；2.固定了第一行，则满足题意的方案最多有一种；3.点击的先后顺序不影响最终结果。枚举第一行的二进制数，最多有 $32$ 种方案，再考虑 2 ~ 5 行，此时他的方案是已经固定了的</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N],backup[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, dy[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">		<span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">		g[a][b] ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n ;; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span>(n --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i ++) cin &gt;&gt; g[i];</span><br><span class="line">		<span class="type">int</span> res = <span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> op = <span class="number">0</span>; op &lt; <span class="number">32</span>; op ++)&#123;<span class="comment">//2 ^ 5种方案，前一行的方案操作直接影响后面的，所以第一行有32种方案，那么只有32种操作不会重复 </span></span><br><span class="line">			<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g);<span class="comment">//保存原数组</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> step = <span class="number">0</span>;<span class="comment">//该方案下 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(op &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">					step ++;</span><br><span class="line">					<span class="built_in">turn</span>(<span class="number">0</span>,i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;i ++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">						step ++;</span><br><span class="line">						<span class="built_in">turn</span>(i + <span class="number">1</span>,j);    </span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(g[<span class="number">4</span>][i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(!flag) res = <span class="built_in">min</span>(res,step);</span><br><span class="line">            <span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(res &gt; <span class="number">6</span>) res = <span class="number">-1</span>;</span><br><span class="line">		cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>货仓选址</title>
    <url>/2023/12/19/%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2023/12/19/%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/image.png" alt></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>将数组排序后，将货仓建在 $x$ 坐标处，其左侧和右侧的商家数量相同的时候最优</p>
</blockquote>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6E5</span> + <span class="number">10</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>,a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> x = a[n / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>(x - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>跑步中位数</title>
    <url>/2024/01/04/%E8%B7%91%E6%AD%A5%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2024/01/04/%E8%B7%91%E6%AD%A5%E4%B8%AD%E4%BD%8D%E6%95%B0/image.png" alt="Alt text"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>动态维护中位数问题。可以建立两个二叉堆，一个大顶堆一个小顶堆，在依次读入整数序列的过程中，设当前序列长度为 $M$,我们始终保持：<br>1.序列中从小到大的 1 ~ M / 2 的整数存储在大顶堆中<br>2.序列中从小到大的 M / 2 ~ M 的整数存储在小顶堆中<br>任何时候，如果某一个堆的元素过多，打破了这个性质，则取出该堆的堆顶插入另外一个堆当中。这样以来，<strong>序列中的中位数就是小顶堆的堆顶</strong></p>
</blockquote>
<p>每读入一个数，如果比中位数小，则插入大顶堆当中，如果比中位数大，则插入小顶堆当中，在插入之后检查并且维护上述性质即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2E6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//小根堆，不是大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x, n;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (n + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;l;<span class="comment">//大根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp1&gt; r;<span class="comment">//小根堆</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> c; cin &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (r.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			r.<span class="built_in">push</span>(c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (c &lt; r.<span class="built_in">top</span>()) &#123;</span><br><span class="line">				l.<span class="built_in">push</span>(c);</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> r.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">while</span> (l.<span class="built_in">size</span>() + <span class="number">1</span> &lt; r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">				l.<span class="built_in">push</span>(r.<span class="built_in">top</span>());</span><br><span class="line">				r.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (r.<span class="built_in">size</span>() &lt; l.<span class="built_in">size</span>()) &#123;</span><br><span class="line">				r.<span class="built_in">push</span>(l.<span class="built_in">top</span>());</span><br><span class="line">				l.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">		    ans.<span class="built_in">push_back</span>(r.<span class="built_in">top</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans)&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cnt ++;</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">10</span> == <span class="number">0</span>) cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">size</span>() % <span class="number">10</span> != <span class="number">0</span>) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>对顶堆</tag>
      </tags>
  </entry>
  <entry>
    <title>认识实习实验</title>
    <url>/2024/01/04/%E8%AE%A4%E8%AF%86%E5%AE%9E%E4%B9%A0%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过浏览器获取网页的过程</p>
<p>资源耗尽，我只要把你们学校的资源耗尽.<br>方式：模拟大量用户请求，TCP，ack报文，每一条都发<br>同样可以用到DHCP服务器里面<br>拿走所有的http</p>
<p>路由器</p>
<p>DNS劫持，ARP欺骗。</p>
<p>用户名root<br>密码kali</p>
<p>ipconfig<br>一款工具</p>
<p>arp欺骗</p>
<p>九个点，搜索栏ett<br>1.0 hosts scanf 扫描出来</p>
<p>地址太大和太小的一般是网关地址，</p>
<p>driftnet i eth0</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>超快速排序</title>
    <url>/2024/01/05/%E8%B6%85%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p><img src="/2024/01/05/%E8%B6%85%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/image.png" alt="Alt text"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>逆序数是一个序列每一个数的左边有多少比他本身大的值。将一个序列排序完整，最小交换次数即是逆序数之和。使用归并排序的同时，将每一个逆序数求出并相加。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bpt __builtin_popcountll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2E6</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;l;<span class="comment">//大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; r;<span class="comment">//小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">merge</span>(l, mid, a);</span><br><span class="line">	<span class="built_in">merge</span>(mid + <span class="number">1</span>, r, a);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt;= mid &amp;&amp; a[i] &lt;= a[j] || j &gt; r) &#123;</span><br><span class="line">			b[k] = a[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cnt += mid - i + <span class="number">1</span>;</span><br><span class="line">			b[k] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">		a[k] = b[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">merge</span>(<span class="number">1</span>,n,a);</span><br><span class="line">		cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>起床困难综合症</title>
    <url>/2023/12/07/%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>$—&gt;$ <a href="https://www.acwing.com/problem/content/1000/"> 传送门</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$drd$ 的防御战线由 $n$ 扇防御门组成。</p>
<p>每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $OR,XOR,AND$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x$ $op$ $t$。</p>
<p>最终 $drd$ 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。</p>
<p>由于 $atm$ 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,…,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。</p>
<p>为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 $drd$ 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 $drd$ 受到多少伤害。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><blockquote>
<p>$3$ $10$ <br><br>$AND$ $5$ <br><br>$OR$ $6$ <br><br>$XOR$ $7$</p>
</blockquote>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><blockquote>
<p>$1$</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>位运算的主要特点之一就是在二进制表示下不进位，因此，每一位是否为 $1$ 是独立的。<strong>$ans$ 的第 $k$ 位只与 $x_o$ 的第 $k$ 位有关。</strong></p>
<p><strong>由此，我们从高位到低位依次考虑每一位填 $1$ 还是 $0$。</strong></p>
<p>这相当于在 $m$ 范围内造出一个符合条件的最大数字 $ans$，这就要 $ans$ 的每一位尽可能的为 $1$。而满足填 $1$ 的条件则是，<strong>已经填好更高位构成的数值加上当前第 $k$ 位的 $1 &lt;&lt; k$ 不超过 $m$，同时当前位置放 $1$ 的贡献大于放 $0$ 的</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> bit,<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">		<span class="type">int</span> x = a[i].second &gt;&gt; bit &amp; <span class="number">1</span>;</span><br><span class="line">		string str = a[i].first;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="string">&quot;AND&quot;</span>) now &amp;= x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;OR&quot;</span>) now |= x;</span><br><span class="line">		<span class="keyword">else</span> now ^= x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;  i &lt;= n; i ++)&#123;</span><br><span class="line">		string s;<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; s &gt;&gt; x;</span><br><span class="line">		a[i] = &#123;s,x&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> val = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">		<span class="type">int</span> res1 = <span class="built_in">cal</span>(i,<span class="number">1</span>),res0 = <span class="built_in">cal</span>(i,<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(val + (<span class="number">1</span> &lt;&lt; i) &lt;= m &amp;&amp; res0 &lt; res1)&#123;</span><br><span class="line">			ans += res1 &lt;&lt; i,val += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans += res0 &lt;&lt; i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>运输层</title>
    <url>/2023/12/24/%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>运输层和网络层的联系和区别</p>
<blockquote>
<p>物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信，但实际上，在计算机网络中进行通信的真正主体是位于通信两端主机中的进程，即两台主机的应用进程互相通信。因此运输层的任务就是为应用进程之间的通信提供服务</p>
</blockquote>
<h3 id="一、用户数据报协议"><a href="#一、用户数据报协议" class="headerlink" title="一、用户数据报协议"></a>一、用户数据报协议</h3><p>UDP报文首部的长度仅八个字节</p>
<h3 id="二、传输控制协议TCP"><a href="#二、传输控制协议TCP" class="headerlink" title="二、传输控制协议TCP"></a>二、传输控制协议TCP</h3><p>可靠传输的工作原理<br>理想传输条件有以下两个特点</p>
<blockquote>
<p>(1) 传输信道不会产生差错<br>(2) 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</p>
</blockquote>
<p>理想状态下，不需要任何措施就能够实现可靠传输，。但实际网络中，都不具备理想传输条件，必须使用一些可靠传输协议、从原本不可靠的传输信道实现可靠传输<br>对于第二点，接收方通过确认报文的窗口值来确认控制发送方的发送窗口值<br>(我能接受多少，你就发多少)</p>
<p>停止等待协议</p>
<blockquote>
<p>每发送完一个分组即停止发送，等待对方的确认，在收到确认后再发送下一个分组</p>
</blockquote>
<p>每发送完一个分组，必须暂时保存已发送的分组的副本，只有在收到相应的确认后才消除暂时保留的分组副本，就如发送缓存和接受缓存</p>
<p>设置一个超时重传时间，在发送一个分组，启动超时重传时间，等待ACK，若丢失或者错误，那么则不会受到确认，这时时间到期就重传</p>
<p>超时计时器的重传时间比分组传输的平均往返时间要长一些，防止不必要的重传</p>
<p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络实现可靠的通信，这种机制通常交作文自动重传请求，重传的请求是发送方自动进行的不需要接收方的通知</p>
<p>滑动窗口 连续ARQ协议</p>
<blockquote>
<p>ARQ的优点是简单，但缺点是信道利用率太低</p>
</blockquote>
<p>采用流水线方式，不用等待确认，发送方连续发送多个分组</p>
<p>发送窗口：位于发送窗口内的分组可以连续发送出去，不需要等待对方确认</p>
<p><img src="/2023/12/24/%E8%BF%90%E8%BE%93%E5%B1%82/image-7.png" alt="Alt text"></p>
<h3 id="三、TCP可靠传输的实现"><a href="#三、TCP可靠传输的实现" class="headerlink" title="三、TCP可靠传输的实现"></a>三、TCP可靠传输的实现</h3><h3 id="四、TCP的流量控制"><a href="#四、TCP的流量控制" class="headerlink" title="四、TCP的流量控制"></a>四、TCP的流量控制</h3><p>流量控制，就是对发送方的发送速率不要太快，要让接收方来得及接收<br>滑动窗口机制很方便的在TCP连接上实现对发送方的流量控制</p>
<p>基本方法：根据接收方根据自己的接受能力控制发送方的流量控制</p>
<h3 id="五、TCP的拥塞控制"><a href="#五、TCP的拥塞控制" class="headerlink" title="五、TCP的拥塞控制"></a>五、TCP的拥塞控制</h3><h3 id="六、TCP的运输连接管理"><a href="#六、TCP的运输连接管理" class="headerlink" title="六、TCP的运输连接管理"></a>六、TCP的运输连接管理</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现指数型枚举</title>
    <url>/2023/12/10/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8C%87%E6%95%B0%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/998/A"> —-&gt; 传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>从 1 ~ $n$ 这 $n$ 个整数随机选取任意多个，输出所有可能的选择方案</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>这等价于每个整数可以选或者不选，所有的方案总数共有 $2 ^ n$ 种。我们用递归来进行求解。在每一次的递归当中分别尝试 <strong>选</strong> 或者 <strong>不选</strong> 两条分支，将尚未确定的整数数量减少 $1$，从而转化为一个规模更小的同类问题</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>$2 ^ n$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : vec) cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">calc</span>(x + <span class="number">1</span>);<span class="comment">//不选</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="built_in">calc</span>(x + <span class="number">1</span>);<span class="comment">//选</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();<span class="comment">//还原现场</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现排列型枚举</title>
    <url>/2023/12/10/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/998/C"> —-&gt; 传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>从 1 ~ $n$ 这 $n$ 个整数排成一列后随机打乱顺序，输出所有可能的次序。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>全排列，将一个大问题转换为小问题，即先考虑十个数的顺序，然后是久个不确定的数的顺序，再到八个乃至一个</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>!n 至 !n * n</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(<span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : vec) cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">calc</span>(x + <span class="number">1</span>);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            vec.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现组合型枚举</title>
    <url>/2023/12/10/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/998/B"> —-&gt; 传送门</a></p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote>
<p>从 1 ~ $n$ 这 $n$ 个整数随机选取 $m$ 个，输出所有可能的选择方案</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>在指数型基础上改一下即可。这里用到了剪枝，在图论当中的运用非常普遍。如果能够及时的发现当前问题是无解的，就不需要到达问题边界才返回结果。如果已经选择了超过 $m$ 个数，或者即使再选上剩余所有的数也不够 $m$ 个，就可以提前得知当前的问题无解。这样我们一旦进入无解的分支就会立刻返回，时间复杂度也就从 $2^n$降低到了 $C_n^m$。</p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><blockquote>
<p>$C_n^m$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec.<span class="built_in">size</span>() &gt; m || vec.<span class="built_in">size</span>() + (n - x + <span class="number">1</span>) &lt; m)&#123;<span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == n + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : vec) cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="built_in">calc</span>(x + <span class="number">1</span>);<span class="comment">//选</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();<span class="comment">//还原现场</span></span><br><span class="line">    <span class="built_in">calc</span>(x + <span class="number">1</span>);<span class="comment">//不选</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>算法进阶指南</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑门电路</title>
    <url>/2023/12/18/%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<p>TTL：半导体，介意导体和绝缘体之间的。</p>
<p>二极管的特点是：单向导电性</p>
<p>由单向导电性呈现开关特性<br>大于 $0.7V$ 呈现闭合的状态，即导通的状况<br>小于则呈现断开的状态</p>
<p>开关时间非常短，纳秒级别，开关时间决定芯片功能<br>反向回流的时间，决定开关闭合时间，压降，降到0.7V后重新回到0.7的时间。<br>做芯片要考虑这个开关时间(实际生产中)</p>
<p>N MOS N沟道 P衬底<br>P MOS P沟道 N衬底</p>
<p>$N^+$ 空穴 电子少<br>$P^-$ 电子<br>NMOS 往上吸附的状态，填满空洞，平衡， 沟道就会形成导通的作用 高电位导通，闭合状态 箭头朝里<br>PMOS 吸附越来越多的电子，高电位截止，变堵。 箭头朝外</p>
<p>74HC138 74LS138 里面构造不一样，一个CMOS一个二极管三极管，因此性能不一样，但是外部使用的功能是一样的(参考电脑，使用方法差不多，但是性能不一样，因为内部构造不一样)</p>
<p>判断是否导通，看是否能产生0.7v的压降<br>1 高电压 0 低电压//有点没有理解，导通和断开的情况</p>
<p>与门或门二极管构成，非门三极管构成</p>
]]></content>
      <categories>
        <category>数字逻辑与数字系统</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
</search>
